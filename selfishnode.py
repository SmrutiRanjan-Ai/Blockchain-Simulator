from node import *


class SelfishNode(Node):
    def __init__(self, creation_time, node_id, bandwidth):
        super().__init__(creation_time, node_id, bandwidth)
        self.hash_power = 'high'
        self.bandwidth = 'FAST'
        self.hash_mean = g.adversary_mining_power
        self.completed_trans = set()
        self.block_qty = 0
        self.type = 'selfish'

    def create_blockchain(self, genesis):
        '''Initialize Blockchain'''
        self.blockchain = Blockchain(genesis)
        self.on_init(0)

    def check_mempool(self, timestamp):
        ''' Check mempool to add into block and trigger mining of block'''
        if not self.busy:
            if timestamp > 0.95 * g.final_timestamp:
                self.mempool_limit = g.TXN_NUM / 100
            if timestamp > 0.98 * g.final_timestamp:
                self.mempool_limit = 0
            if len(self.mempool) > self.mempool_limit:
                self.create_block(timestamp, self.chain)

    def on_init(self, timestamp):
        public_chain = self.blockchain.tree.longest_chain()
        self.chain = public_chain
        self.private_branch = []
        self.private_len = 0
        if g.mining_log:
            print(timestamp, "I am Initiated")

    def receive_message(self, timestamp, message, sender):
        if message.type == 'txn':
            if message.content not in self.mempool:
                self.mempool.add(message.content)
            self.broadcast_message(timestamp, message, sender)
            if g.message_log: print(timestamp, self, " Received Transaction", message.content, "from ", sender.id)
        if message.type == 'blk':
            if message.content not in self.received_blk:
                if g.message_blk_log: print(timestamp, self, " Received Block", message.content, "from ", sender.id)
                self.received_blk.add(message.content)
                self.receive_blk(timestamp, message.content, sender)
                ''' Selfish Miners does not forward block generated by other nodes'''

    def receive_blk(self, timestamp, block, sender):
        print(timestamp, "99 recive blk", block, block.header['prev_hash'])
        self.check_selfish(timestamp, block, sender)

    def check_selfish(self, timestamp, block, sender):
        '''Check Lead and take action on received blk from honest miners'''
        public_chain = self.blockchain.tree.longest_chain()
        public_chain_blkid = []
        for i in public_chain:
            public_chain_blkid.append(i.header['blkid'])
        d_prev = len(self.chain) - len(public_chain)
        status, code = self.blockchain.add_block_to_chain(block, timestamp)
        if g.mining_log:
            print(timestamp, "selfish added honest block", block, status, code)
        print(timestamp,"Lead is", d_prev)
        for c in public_chain:
            if c.header['block_hash'] == block.header['prev_hash']:
                if d_prev == 1:
                    ''' Assignment Part A Section 1 
                    Lead is 1 and honest miners find one block. publish the private block
                    '''
                    for i in self.chain:
                        if i.header['blkid'] not in public_chain_blkid:
                            status, code = self.blockchain.add_block_to_chain(i, timestamp)
                            print(timestamp, d_prev, "99 added private block to public", i, status, code)
                            timestamp += lag
                            message = Message('blk', i)
                            self.broadcast_message(timestamp, message, self)

                    event = Event(timestamp, [self.check_mempool, timestamp])
                    des.heapq.heappush(des.q, event)
                    ''' After publishing reinitialize private chain'''
                    self.on_init(timestamp)

                if d_prev == 2:
                    ''' Assignment Part A Section 2
                    Lead is 2 and honest miners find one block. publish only  those blocks that 
                    corresponds to the received honest block
                    '''
                    for i in self.chain:
                        if i.header['blkid'] not in public_chain_blkid:
                            status, code = self.blockchain.add_block_to_chain(i, timestamp)
                            print(timestamp, d_prev, "99 added private block", block, status, code)
                            timestamp += lag
                            message = Message('blk', i)
                            self.broadcast_message(timestamp, message, self)
                    event = Event(timestamp, [self.check_mempool, timestamp])
                    des.heapq.heappush(des.q, event)

                elif d_prev > 2:
                    ''' Assignment Part A Section 3
                    Lead is gtreater than 2 and honest miners find one block. publish  releasing a subchain 
                    that ends with that block which enters into competition with the new honest block.
                    '''
                    for i in self.chain:
                        if i.header['blkid'] not in public_chain_blkid:
                            status, code = self.blockchain.add_block_to_chain(i, timestamp)
                            print(timestamp, d_prev, "99 added private block", block, status, code)
                            timestamp += lag
                            message = Message('blk', i)
                            event = Event(timestamp, [self.broadcast_message, timestamp, message, self])
                            des.heapq.heappush(des.q, event)
                            if i.header['prev_hash'] == block.header['prev_hash']:
                                break

                    event = Event(timestamp, [self.check_mempool, timestamp])
                    des.heapq.heappush(des.q, event)
                else:
                    ''' WHen lead is 0 and honest miners find one block reinitialize private chain'''
                    self.on_init(timestamp)
                break

    def end_broadcast(self, timestamp):
        for i in self.private_branch:
            for n in g.node_list:
                n.blockchain.add_block_to_chain(i, timestamp)

    def add_block(self, timestamp, blkid):
        ''' Add a block after mining'''
        block = self.pending_block
        if block is not None:
            print(timestamp, "selfish mined a block", block)
            self.chain.append(block)
            self.check_completed_trans(self.chain)
            self.block_qty += 1
        self.pending_block = None
        self.busy = False
        event = Event(timestamp + lag, [self.check_mempool, timestamp + lag])
        des.heapq.heappush(des.q, event)

    def check_completed_trans(self, chain=None):
        ''' Remove Trans after adding block to chain'''
        if chain is None:
            chain = self.blockchain.tree.longest_chain()
        valid_trans_list = self.blockchain.get_chain_trans_list(chain)
        li = list(self.mempool)
        c_li = list(self.completed)
        temp = set()
        for i in c_li:
            if i not in valid_trans_list:
                temp.add(i)
                self.completed.discard(i)
        for i in li:
            if i in valid_trans_list:
                self.mempool.discard(i)
                self.completed.add(i)
        for i in temp:
            self.mempool.add(i)
